import torch
import numpy as np
import io
import os
import folder_paths
from PIL import Image, ImageOps

# ==================================================================================
# HolafBenchmarkPlotter Node - Documentation
# ==================================================================================
#
# Author: Cline (AI Assistant) for Holaf
# Date: 2025-04-02 (Updated)
#
# Purpose:
# This node reads a benchmark report CSV file (generated by HolafBenchmarkRunner)
# and creates two plots visualizing the Pixels per Second performance against resolution:
# 1. A plot with a standard light theme.
# 2. A plot with a dark theme.
#
# How it works:
# 1. Takes the CSV report data as a multi-line string input.
# 2. Reads the CSV data from the string using the pandas library.
# 3. Uses the matplotlib library to generate two line plots:
#    - X-axis: Resolution (extracted from the 'Resolution' column, e.g., width from 'WxH').
#    - Y-axis: Pixels/s (from the 'Pixels/s' column).
# 4. Adds a title and axis labels to both plots.
# 5. Extracts system and model information (if present) from the CSV data.
# 6. Groups data by model name (`Model Name` column) if multiple models are present in the CSV.
# 7. Plots separate curves for each model on the same axes for both plots.
# 8. Adds a legend to identify the curves on both plots.
# 9. Extracts system information (if present) and adds it as text below each plot, styled appropriately for the theme.
# 10. Converts both generated plots into image formats compatible with ComfyUI (Torch tensors).
# 11. Outputs the plots as two separate IMAGE types (light and dark).
#
# Inputs:
# - report_text (STRING): The benchmark report data formatted as a CSV string.
#   (Expected columns include: Resolution, Pixels/s, Model Name, Model Type, CPU, RAM (GB), GPU, GPU Memory (GB), OS)
# - plot_title (STRING): Optional title for the generated plots.
#
# Outputs:
# - plot_image_light (IMAGE): The generated plot with a light theme.
# - plot_image_dark (IMAGE): The generated plot with a dark theme.
#
# Dependencies:
# - Requires external Python libraries: pandas and matplotlib.
#   These need to be installed in the Python environment used by ComfyUI.
#   You can typically install them using pip:
#   `pip install pandas matplotlib`
#   (Ensure you run this in the correct Python environment/venv for ComfyUI).
# - Requires standard libraries: io, os, numpy, PIL (Pillow).
# - Relies on ComfyUI's internal modules: torch, folder_paths.
#
# Error Handling:
# - Checks if the required libraries (pandas, matplotlib) are installed.
# - Handles potential errors during CSV parsing (e.g., empty string, incorrect format) or plotting.
# - Returns two blank images in case of errors.
#
# Design Choices:
# - Two separate outputs are provided for flexibility, allowing users to choose the theme they prefer downstream.
# - Matplotlib's style contexts are used to manage the theming efficiently.
# - System information is placed below the plot to avoid overlapping with potentially complex legends or plot lines.
# - Error handling returns blank tensors to prevent workflow crashes.
#
# ==================================================================================

# --- Dependency Check ---
try:
    import pandas as pd
    _pandas_available = True
except ImportError:
    _pandas_available = False
    print("[HolafBenchmarkPlotter] Warning: pandas library not found. This node requires pandas.")
    print("[HolafBenchmarkPlotter] Please install it: pip install pandas")

try:
    import matplotlib.pyplot as plt
    import matplotlib
    # Set a non-interactive backend suitable for servers/scripts
    matplotlib.use('Agg')
    _matplotlib_available = True
except ImportError:
    _matplotlib_available = False
    print("[HolafBenchmarkPlotter] Warning: matplotlib library not found. This node requires matplotlib.")
    print("[HolafBenchmarkPlotter] Please install it: pip install matplotlib")
# --- End Dependency Check ---

class HolafBenchmarkPlotter:
    def __init__(self):
        pass

    @classmethod
    def INPUT_TYPES(s):
        return {
            "required": {
                # Changed input name and added multiline for potentially long CSV strings
                "report_text": ("STRING", {"default": "", "multiline": True}),
            },
            "optional": {
                 "plot_title": ("STRING", {"default": "Benchmark: Pixels/s vs Resolution", "multiline": True}), # Allow multiline title too
            }
        }

    RETURN_TYPES = ("IMAGE", "IMAGE",) # Added second IMAGE output
    RETURN_NAMES = ("plot_image_light", "plot_image_dark",) # Renamed first, added second name
    FUNCTION = "plot_benchmark"
    CATEGORY = "Holaf"

    # Function to convert Matplotlib plot to PIL Image -> NumPy array -> Torch Tensor
    def plot_to_tensor(self, fig):
        buf = io.BytesIO()
        fig.savefig(buf, format='png', bbox_inches='tight')
        buf.seek(0)
        image = Image.open(buf)
        image = ImageOps.exif_transpose(image) # Ensure correct orientation
        image = image.convert("RGB")
        image_np = np.array(image).astype(np.float32) / 255.0
        image_tensor = torch.from_numpy(image_np)[None,] # Add batch dimension
        plt.close(fig) # Close the figure to free memory
        return image_tensor

    # Changed function signature to accept report_text
    def plot_benchmark(self, report_text, plot_title="Benchmark: Pixels/s vs Resolution"):
        if not _pandas_available or not _matplotlib_available:
            error_msg = "Missing required libraries: "
            if not _pandas_available: error_msg += "pandas "
            if not _matplotlib_available: error_msg += "matplotlib"
            print(f"[HolafBenchmarkPlotter] Error: {error_msg}")
            # Return two blank images
            blank_tensor = torch.zeros([1, 64, 64, 3], dtype=torch.float32)
            return (blank_tensor, blank_tensor,)

        # Check if the input string is empty
        if not report_text or not report_text.strip():
            print(f"[HolafBenchmarkPlotter] Error: Input report_text is empty.")
            blank_tensor = torch.zeros([1, 64, 64, 3], dtype=torch.float32)
            return (blank_tensor, blank_tensor,)

        try:
            # Read the CSV data from the string using io.StringIO
            csv_io = io.StringIO(report_text)
            df = pd.read_csv(csv_io)
            csv_io.close() # Close the StringIO object

            # --- Data Validation and Preparation ---
            # Base required columns for the plot itself
            required_plot_columns = ["Resolution", "Pixels/s"]
            if not all(col in df.columns for col in required_plot_columns):
                print(f"[HolafBenchmarkPlotter] Error: CSV missing required plot columns ({required_plot_columns}). Found: {list(df.columns)}")
                blank_tensor = torch.zeros([1, 64, 64, 3], dtype=torch.float32)
                return (blank_tensor, blank_tensor,)

            # Optional columns for system info text (Model Name/Family handled by legend)
            system_info_columns = ["CPU", "RAM (GB)", "GPU", "GPU Memory (GB)", "OS"]
            # Extract system info from the first row (should be consistent)
            found_system_info = {col: df.iloc[0][col] for col in system_info_columns if col in df.columns and not pd.isna(df.iloc[0][col])}

            # Extract resolution (assuming format 'WxH', take W) and convert Pixels/s
            try:
                # Extract width from 'Resolution' column (e.g., '512x512' -> 512)
                df['ResValue'] = df['Resolution'].astype(str).str.split('x', expand=True)[0].astype(int)
                # Convert 'Pixels/s' to numeric, coercing errors to NaN
                df['PixelsPerSec'] = pd.to_numeric(df['Pixels/s'], errors='coerce')
                # Drop rows where conversion failed
                df.dropna(subset=['ResValue', 'PixelsPerSec'], inplace=True)
            except Exception as e:
                 print(f"[HolafBenchmarkPlotter] Error processing CSV data: {e}")
                 blank_tensor = torch.zeros([1, 64, 64, 3], dtype=torch.float32)
                 return (blank_tensor, blank_tensor,)

            if df.empty:
                 print(f"[HolafBenchmarkPlotter] Error: No valid numeric data found in CSV for plotting.")
                 blank_tensor = torch.zeros([1, 64, 64, 3], dtype=torch.float32)
                 return (blank_tensor, blank_tensor,)

            # Sort by resolution for a clean plot (do this once)
            df = df.sort_values(by='ResValue')

            # --- Helper function to create a plot (avoids code duplication) ---
            def create_plot(style_context=None, text_color='black', grid_color='lightgray', bbox_color='lightgray'):

                # Define the actual plotting logic inside a nested function or directly here
                def _do_actual_plotting():
                    fig, ax = plt.subplots(figsize=(12, 7)) # Increased height slightly for bottom text

                    # Group data by model name and plot each group
                    if 'Model Name' in df.columns:
                        grouped = df.groupby('Model Name')
                        for name, group in grouped:
                            group = group.sort_values(by='ResValue') # Ensure each group is sorted
                            ax.plot(group['ResValue'], group['PixelsPerSec'], marker='o', linestyle='-', label=name)
                        ax.legend(loc='best', fontsize='small') # Changed legend location
                    else:
                        # Fallback if no Model Name column
                        df_sorted = df.sort_values(by='ResValue') # Use already sorted df
                        ax.plot(df_sorted['ResValue'], df_sorted['PixelsPerSec'], marker='o', linestyle='-')
                        print("[HolafBenchmarkPlotter] Warning: 'Model Name' column not found. Plotting single curve.")

                    # Add labels and title with specified color
                    ax.set_xlabel("Resolution (Width in Pixels)", color=text_color)
                    ax.set_ylabel("Performance (Pixels per Second)", color=text_color)
                    ax.set_title(plot_title, color=text_color)
                    ax.grid(True, which='both', linestyle='--', linewidth=0.5, color=grid_color)

                    # Set tick colors
                    ax.tick_params(axis='x', colors=text_color)
                    ax.tick_params(axis='y', colors=text_color)

                    # Set spine colors (optional, but improves dark theme)
                    for spine in ax.spines.values():
                        spine.set_edgecolor(text_color)


                    # --- Add System Info Text Below Plot ---
                    if found_system_info:
                        info_lines = ["System Info:"]
                        if "GPU" in found_system_info: info_lines.append(f"GPU: {found_system_info['GPU']} ({found_system_info.get('GPU Memory (GB)', 'N/A')} GB)")
                        if "CPU" in found_system_info: info_lines.append(f"CPU: {found_system_info['CPU']}")
                        if "RAM (GB)" in found_system_info: info_lines.append(f"RAM: {found_system_info['RAM (GB)']} GB")
                        if "OS" in found_system_info: info_lines.append(f"OS: {found_system_info['OS']}")

                        info_text = "\n".join(info_lines)
                        # Place text below the plot area, centered horizontally
                        plt.figtext(0.5, 0.01, info_text, ha="center", va="bottom", fontsize=8, wrap=True, color=text_color,
                                    bbox=dict(boxstyle='round,pad=0.3', fc=bbox_color, alpha=0.7))
                        # Adjust subplot parameters to make room for the text at the bottom
                        plt.subplots_adjust(bottom=0.25) # Adjust bottom margin more if needed
                    else:
                        fig.tight_layout() # Use tight layout if no text

                    # Convert plot to tensor (function closes the figure)
                    plot_tensor = self.plot_to_tensor(fig)
                    return plot_tensor

                # Apply context manager only if style_context is provided
                if style_context:
                    with plt.style.context(style_context):
                        return _do_actual_plotting()
                else:
                    # Otherwise, just run the plotting function with default style
                    return _do_actual_plotting()


            # --- Generate Light Theme Plot ---
            plot_tensor_light = create_plot(
                style_context=None, # Default light style
                text_color='black',
                grid_color='lightgray',
                bbox_color='lightgray'
            )

            # --- Generate Dark Theme Plot ---
            plot_tensor_dark = create_plot(
                style_context='dark_background',
                text_color='white',
                grid_color='gray',
                bbox_color='dimgray' # Darker background for the text box
            )


            print(f"[HolafBenchmarkPlotter] Plots generated successfully from input text.")
            return (plot_tensor_light, plot_tensor_dark,) # Return both tensors

        except pd.errors.EmptyDataError:
            print(f"[HolafBenchmarkPlotter] Error: Parsed CSV data from input string is empty.")
            blank_tensor = torch.zeros([1, 64, 64, 3], dtype=torch.float32)
            return (blank_tensor, blank_tensor,)
        except Exception as e:
            print(f"[HolafBenchmarkPlotter] Error generating plot from input text: {e}")
            # Consider logging the full traceback here for debugging if needed
            import traceback
            print(traceback.format_exc()) # Print traceback for better debugging
            blank_tensor = torch.zeros([1, 64, 64, 3], dtype=torch.float32)
            return (blank_tensor, blank_tensor,)


# Node class mappings for ComfyUI
NODE_CLASS_MAPPINGS = {
    "HolafBenchmarkPlotter": HolafBenchmarkPlotter
}

NODE_DISPLAY_NAME_MAPPINGS = {
    "HolafBenchmarkPlotter": "Benchmark Plotter (Holaf)" # Keep display name consistent
}
